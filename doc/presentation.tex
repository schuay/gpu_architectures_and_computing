\documentclass{beamer}

\usepackage{comment}
\usepackage{default}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{graphicx}

\graphicspath{{./images/}}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{Gray}{gray}{0.5}

\lstset{
    language=C,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{An Efficient Parallel Signal Temporal Logic Implementation}
\author{
	Bernhard Denner,
	Jakob Gruber,
	Mino Sharkhawy
}

\begin{document}

\maketitle

\begin{frame}
\frametitle{Signal Temporal Logic}
\begin{itemize}
    \item describing timed behaviours of continuous systems (time discrete signals)
    \item monitoring STL 
          \begin{itemize}
        	\item evaluate a satisfaction function of STL formula
        	\item boolean semantic
        	\item quantitative semantic, robustness of satisfation
          \end{itemize}
    \item based on
          \begin{itemize}
        	\item functions (like $\leq$ ), satisfaction of function
        	\item logical operators (NOT, AND, OR), combining satisfactions
        	\item temporal operators (UNTIL, EVENTUALLY, GLOBALLY), take timed behaviour into account
          \end{itemize}
\end{itemize}
% Very brief recap
\end{frame}

\begin{frame}
\frametitle{Objectives}
\begin{itemize}
	\item reimplement the robustness calculation operators with CUDA
	\begin{itemize}
	    \item based on algorithms presented in paper \emph{Efficient Robust Monitoring for STL} (A. Donze, T. Ferrere, O. Maler)
	    \item main task: find a efficient parallel solution for the operator implementation
	    \item very challenging for some operators
    \end{itemize}
	\item main goal: be much faster than the reference implementation (Breach)
	\item but always be as precise as the Breach
	\item if possible: integrate the CUDA implementation in MATLAB (Breach)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Work Division}
\begin{itemize}
\item A lightweight on-the-fly plan
\item Organized through the bitbucket issue tracker
\item Jakob: Test suite, AND, UNTIL
\item Mino: EVTL, BEVTL
\item Bernhard: AND, Benchmark framework, Matlab integration
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Testing and Benchmarks}
\begin{itemize}
\item CTest: Integration into build system
\item Check: Test framework
\item One test suite per operator
\item Comparison against Breach results
\item Benchmark framework: compare performance against Breach
\begin{itemize}
	\item test with various signal sizes
	\item generated signals and random signals
\end{itemize}
\end{itemize}
\begin{figure}[H]
    \includegraphics[scale=0.3]{bm_sig3_ev_alw.png}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Initial Plan}
% What did we initially want to do?
\begin{itemize}
\item Primitive operators
\begin{itemize}
\item NOT - done
\item AND - done
\item unbounded EVTL - done
\item unbounded UNTIL - partially done
\item bounded EVTL - done
\end{itemize}
\item Test suite - done
\item Benchmarking - done
\item Parser integration - not done
\item Optimization - not done
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Problems}
\begin{itemize}
\item Getting the breach reference implementation to work and to produce results for
        comparison was difficult.
\item Some operators very hard to parallelize
\begin{itemize}
\item Fully parallelized UNTIL needs infinite amount of memory
\item Even partial parallelization of UNTIL very difficult
\item Running time of parallel BEVTL depends on the window size
\end{itemize}
\item Floating point calculations very inaccurate, best accuracy: $5*10^{-5}$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Results}
\begin{itemize}
\item NOT trivially parallelizable
\item AND, EVTL involved, but possible in $O(f(n,p))$
\item UNTIL mostly possible, but one sequential part remains
\item BEVTL parallelizable, but dependent on window size $O(f(n,p,w))$
\end{itemize}
% Also, why we ended up with less than planned, what were the difficulties?
\end{frame}

\begin{frame}
\frametitle{Benchmarks - AND}
\begin{figure}[H]
    \includegraphics[scale=0.5]{bm_and.png}
    \caption{
        \label{fig:bm_and}
        Benchmark result: AND Operator}
\end{figure}
\end{frame}
\note{
AND Benchmarks \\
* Logarithmic scale \\
* 2 Test sets in one: Left side regular signal, Right side random \\
* CUDA ~ 1 order of magnitude lower.
}

\begin{frame}
\frametitle{Benchmarks - EVTL}
\begin{figure}[H]
    \includegraphics[scale=0.5]{bm_evtl.png}
    \caption{
        \label{fig:bm_evtl}
        Benchmark result: EVTL Operator}
\end{figure}
\end{frame}
\note{
Unbounded EVTL: Similar behavior to AND.
}

\begin{frame}
\frametitle{Benchmarks - UNTIL}
\begin{figure}[H]
    \includegraphics[scale=0.5]{bm_until.png}
    \caption{
        \label{fig:bm_until}
        Benchmark result: UNTIL Operator}
\end{figure}
\end{frame}
\note{
First problematic operator \\
* Complexity the same as breach since our implementation uses a sequential component
}

\begin{frame}
\frametitle{Benchmarks - BEVTL}
\begin{figure}[H]
    \includegraphics[scale=0.4]{bm_bevtl.png}
    \caption{
        \label{fig:bm_bevtl}
        Benchmark result: BEVTL Operator}
\end{figure}
\end{frame}
\note{
* Diagram might be misleading since window size increases together with n \\
* Fully parallel, so I'd expect much better performance if the number of points within a window
  stayed roughly constant \\
* Breach crashed with larger data sets \\
* 1 mil set also exceeds the GPU memory capacity
}

\begin{frame}
\frametitle{Lessons Learned}
\begin{itemize}
\item Create benchmarks at the beginning
\item Floating point arithmetic
\item Simple POC before implementation
\item Ensure task is possible before barging in
\end{itemize}
\end{frame}
\note{
* Benchmarks: to know which components need optimization and how they compare with 
  a reference implementation \\
* Floats: Problems comparing for equality because of introduced rounding errors \\
* POC: For the more difficult operators, it helped to start with a simple sequential implementation
  to check the algorithm for correctness and replace it bit by bit with parallel algorithms. \\
* Task possible: Nice to know (or have a good idea) whether the project is possible instead of 
  finding out in the middle that parts won't work.
}

\begin{frame}
\frametitle{Future Tasks}
\begin{itemize}
\item Completely parallel UNTIL, EVTL not dependent on window size
\item Multi-GPU
\item Optimizations
\item Processing entire formulas
\item Arbitrary expressions in input formulas
\end{itemize}
\end{frame}
\note{
* Find scalable UNTIL/BEVTL implementations, or provide impossibility proof. \\
* Adapt our algorithms to multiple GPUs \\
* No time to optimize operators, I'm sure performance could still be improved \\
* Process entire formulas instead of operators only
}

\begin{frame}
\frametitle{The End}
\end{frame}

\end{document}
