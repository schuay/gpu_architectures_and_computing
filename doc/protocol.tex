\documentclass[a4paper,10pt]{article}

\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}

\definecolor{Gray}{gray}{0.5}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}

\lstset{
    language=C++,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{
	An Efficient Parallel Signal Temporal Logic Implementation \\
    VU GPU Architectures \& Computing \\
    SS 2013
}

\author{
    Bernhard Denner,
    Jakob Gruber,
    Mino Sharkhawy
}

\renewcommand{\And}{\wedge}
\newcommand{\Or}{\vee}
\newcommand{\Neg}{\neg}
\newcommand{\Impl}{\rightarrow}
\newcommand{\Until}{\mathbf{U}}
\newcommand{\Evtl}{\diamondsuit}
\newcommand{\Alw}{\square}
\newcommand{\Buntil}{\mathbf{U}_I}
\newcommand{\Bevtl}{\diamondsuit_I}
\newcommand{\Balw}{\square_I}

\begin{document}

\begin{comment}
Problem statement, State of the art (semantics, ...), Sequential algorithms, Parallel ..., Test cases, benchmarks, How the project went, what we did.
\end{comment}

\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Background}

Temporal logic describes a system of rules for representing and reasoning about propositions
qualified in terms of time\footnote{\url{http://en.wikipedia.org/wiki/Temporal_logic}}.
It consists of the usual logical operators $\And, \Or, \Neg, \Impl$ as well as
some collection of modal operators. In particular, signal temporal logic as used in this
project defines the following additional operators:

\begin{itemize}
\item $a \: \Until \: b$: The \textbf{UNTIL} operator is true if and only if $a$ is true
      at all points until some point at which $b$ becomes true.
\item $\Evtl \: a$: The \textbf{EVENTUALLY} operator is true iff a becomes true at any point
      in the future. It is equivalent to $\mathit{true} \: \Until \: a$.
\item $\Alw \: a$: The \textbf{ALWAYS} operator is true iff a is true at every point in the range.
      It is equivalent to $\neg \Evtl \neg a$.
\end{itemize}

Each of these three operators also has a bounded variant ($\Buntil, \: \Bevtl, \Balw$) which
for each point $a$ in the signal restricts the processed interval to $a + I$.

Furthermore, besides the usual boolean semantics (which always evaluate to either \textit{true} or
\textit{false}), signal temporal logic is also defined over real-valued quantitative semantics which
can be interpreted as indicating ``how much'' a condition is satisfied at any given point.

\section{State of the Art} \label{sec:stateoftheart}

A. Donze, T. Ferrere, O. Maler, \emph{Efficient Robust Monitoring for STL} describes
sequential algorithms calculating robustness signals for all STL operators within linear
time complexity.

Algorithms are provided for the $\And, \Neg, \Until, \Evtl, \Bevtl$ operators, which are then used
to construct all remaining operators as follows:

\begin{align}
a \Or b &= \Neg (\Neg a \And \Neg b) \\
a \: \Until_{[s, t]} \: b &= \Alw_{[0, s]} \And \Evtl_{[s, t]} \And \Evtl_{[s, s]} (a \: \Until \: b)\\
\Alw \:  a &= \Neg \Evtl  \Neg a \\
\Balw \: a &= \Neg \Bevtl \Neg a
\end{align}

Sequential implementations are outlined in the following sections. Each signal consists
of a sequence of \lstinline|sigpt_t| structs:

\begin{lstlisting}
typedef struct {
    float t;  /* The time. */
    float y;  /* The value. */
    float dy; /* The derivative. */
} sigpt_t;
\end{lstlisting}

\subsection{NOT}

The $\Neg$ operator simply negates all signals points.

\begin{figure}[ht]
\begin{lstlisting}
Compute(NOT, y) {
    /* ny is the number of points in y. */
    for (i = 0; i < ny; i++) {
        result[i].y = -y[i].y;
    }
    return result;
}
\end{lstlisting}
\label{fig:not}
\caption{The NOT operator.}
\end{figure}

\subsection{AND}

The $\And$ operator basically performs a point-wise minimum between both incoming signals.
This is complicated by the fact that signal values need to be interpolated for all
cases in which contains time points not found in the other signal. Additionally,
all intersections between both signals must also be added to the result.

\begin{figure}[ht]
\begin{lstlisting}
Compute(AND, x, y) {
    ts = /* union of all time points in x, y, and all intersections between them */;
    i = 0;
    for (t in ts) {
        result[i].t = t;
        result[i].y = min(
            interpolate(x at time t),
            interpolate(y at time t));
        i++;
    }
    return result;
}
\end{lstlisting}
\label{fig:and}
\caption{The AND operator.}
\end{figure}

\subsection{EVTL}

The sequential $\Evtl$ implementation is simply a reverse running maximum, again
complicated by the existence of intersections between the current running maximum
and the signal.

\begin{figure}[ht]
\begin{lstlisting}
Compute(EVTL, y) {
    mx = y[ny - 1].y;
    result.push_front({ y[ny - 1].t, mx });

    for (i = ny - 2; i >= 0; i--) {
        if (y[i + 1].y < mx && y[i].y > mx) {
            t = /* Interpolate time of intersection */
            result.push_front({ t, mx });
        }
        mx = max(y[i].y, mx);
        result.push_front({ y[i].t, mx });
    }
    return result
}
\end{lstlisting}
\label{fig:evtl}
\caption{The EVTL operator.}
\end{figure}

\subsection{UNTIL}

$\Until$ is composed of several $\Evtl, \And$, and $\Neg$ operations performed on
individual segments. Note that \lstinline|z0| always references the value from the
previous iteration. This is also the only operator which actually uses the signal derivative
values \lstinline|signal.dy|.

\begin{figure}[ht]
\begin{lstlisting}
Compute(UNTIL, x, y) {
    z0 = -INFINITY;
    for (i = nx - 1; i >= 0; i--) {
        if (x[i].dy <= 0) {
            z1 = Compute(EVTL, y);
            z2 = Compute(AND, z1, x);
            z3 = Compute(AND, const_signal(x[i + 1].y), z0);
        } else {
            z1 = Compute(AND, y, const_signal(x[i].y));
            z2 = Compute(EVTL, z1);
            z3 = Compute(AND, x, z0);
        }
        z4 = Compute(OR, z2, z3);
        result.push_front(/* All points in z4. */);
        z0 = const_signal(z4[0].y);
    }
    return result
}
\end{lstlisting}
\label{fig:until}
\caption{The UNTIL operator.}
\end{figure}

\subsection{BEVTL}

The $\Bevtl$ calculates the maximum of the window $t + I$ for each $t$. It is
essentially a running maximum of the entire signal with a window size of $b - a$,
where $I = [a,b]$. To do this, the sequential implementation iterates over the signal
and keeps a list of points, which still have to be considered for the current time.

You can see the algorithm in Listing~\ref{fig:bevtl}.

\begin{figure}[ht]
\begin{lstlisting}
Compute(BEVTL, y, a, b) {
    ya = shift(Compute(EVTL, y), a);
    yb = shift(Compute(EVTL, y), b);
    yd = Compute(AND, ya, yb);
    s = y[0].t - b;
    t = s;
    i = 0;
    M = {};
    while (t + a < y[n - 1].t) {
        t = min(y[min(M)].t - a, y[i + 1].t - b);
        if (t == y[min(M)].t - a) {
            M.del(min(M));
            s = t;
        }
        if (t == y[i + 1].t - b) {
            while (y(y[i + 1].t - b) >= y(max(M)) && M != {}) {
                M.del(max(M));
            }
            M.add(i+1);
            i += 1;
        }
        if (s >= y[0].t) {
            if (M == {}) {
                z[s:t] = yd[s:t];
            } else {
                z[s:t] = Compute(OR, yd[s:t], y[min(M)]);
            }
        }
    }
    return z;
}
\end{lstlisting}
\label{fig:bevtl}
\caption{The BEVTL operator.}
\end{figure}

\section{Problem Statement}

The algorithms shown in section \ref{sec:stateoftheart} all have linear complexity
but are completely sequential.
GPUs offer the potential for vast performance improvements, but require algorithms
which are suited to their highly parallel architectures. The objective of this project
was to attempt to parallelize all algorithms required for STL processing. In case of success, these could then be

\begin{itemize}
\item benchmarked and compared to the existing Breach\footnote{\url{http://www.eecs.berkeley.edu/~donze/breach_page.html}} implementation,
\item swapped into Breach to replace the sequential algorithms, and
\item integrated with a parser in order to process entire STL formulas.
\end{itemize}

\section{Implementation}

\subsection{Tools}

\subsection{Test Environment}
\subsection{Parallel Algorithms}

\subsubsection{NOT}

The parallel NOT operator does exactly the same thing as the sequential one. It
schedules the entire signal to multiple processors on the GPU which in turn negate
the set of points they have been assigned.

\subsubsection{AND}

\subsubsection{EVTL}

\subsubsection{UNTIL}

\subsubsection{BEVTL}

% Who did what? Challenges? ... ?

\section{Results}

\end{document}
