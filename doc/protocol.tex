\documentclass[a4paper,10pt]{article}

\usepackage[usenames,dvipsnames]{color}
\usepackage{comment}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}

\definecolor{Gray}{gray}{0.5}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}

\lstset{
    language=C++,
    basicstyle=\ttfamily,
    keywordstyle=\color{OliveGreen},
    commentstyle=\color{Gray},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    showspaces=false,
    showtabs=false,
    numbers=left,
}

\title{
	An efficient parallel signal temporal logic implementation \\
    VU GPU Architectures \& Computing \\
    SS 2013
}

\author{
    Bernhard Denner,
    Jakob Gruber,
    Mino Sharkhawy
}

\renewcommand{\And}{\wedge}
\newcommand{\Or}{\vee}
\newcommand{\Neg}{\neg}
\newcommand{\Impl}{\rightarrow}
\newcommand{\Until}{\mathbf{U}}
\newcommand{\Evtl}{\diamondsuit}
\newcommand{\Alw}{\square}
\newcommand{\Buntil}{\mathbf{U}_I}
\newcommand{\Bevtl}{\diamondsuit_I}
\newcommand{\Balw}{\square_I}

\begin{document}

\begin{comment}
Problem statement, State of the art (semantics, ...), Sequential algorithms, Parallel ..., Test cases, benchmarks, How the project went, what we did.
\end{comment}

\maketitle
\pagebreak
\tableofcontents
\pagebreak

\section{Background}

Temporal logic describes a system of rules for representing and reasoning about propositions
qualified in terms of time\footnote{\url{http://en.wikipedia.org/wiki/Temporal_logic}}.
It consists of the usual logical operators $\And, \Or, \Neg, \Impl$ as well as
some collection of modal operators. In particular, signal temporal logic as used in this
project defines the following additional operators:

\begin{itemize}
\item $a \: \Until \: b$: The \textbf{UNTIL} operator is true if and only if $a$ is true
      at all points until some point at which $b$ becomes true.
\item $\Evtl \: a$: The \textbf{EVENTUALLY} operator is true iff a becomes true at any point
      in the future. It is equivalent to $\mathit{true} \: \Until \: a$.
\item $\Alw \: a$: The \textbf{ALWAYS} operator is true iff a is true at every point in the range.
      It is equivalent to $\neg \Evtl \neg a$.
\end{itemize}

Each of these three operators also has a bounded variant ($\Buntil, \: \Bevtl, \Balw$) which
for each point $a$ in the signal restricts the processed interval to $a + I$.

Furthermore, besides the usual boolean semantics (which always evaluate to either \textit{true} or
\textit{false}), signal temporal logic is also defined over real-valued quantitative semantics which
can be interpreted as indicating ``how much'' a condition is satisfied at any given point.

\section{State of the Art}

A. Donze, T. Ferrere, O. Maler, \emph{Efficient Robust Monitoring for STL} describes
sequential algorithms calculating robustness signals for all STL operators within linear
time complexity.

Algorithms are provided for the $\And, \Neg, \Until, \Evtl, \Bevtl$ operators, which are then used
to construct all remaining operators as follows:

\begin{align}
a \Or b &= \Neg (\Neg a \And \Neg b) \\
a \: \Until_{[s, t]} \: b &= \Alw_{[0, s]} \And \Evtl_{[s, t]} \And \Evtl_{[s, s]} (a \: \Until \: b)\\
\Alw \:  a &= \Neg \Evtl  \Neg a \\
\Balw \: a &= \Neg \Bevtl \Neg a
\end{align}

Sequential implementations are outlined in the following sections. Each signal consists
of a sequence of \lstinline|sigpt_t| structs:

\begin{lstlisting}
typedef struct {
    float t;  /* The time. */
    float y;  /* The value. */
    float dy; /* The derivative. */
} sigpt_t;
\end{lstlisting}

\subsection{NOT}

The $\Neg$ operator simply negates all signals points.

\begin{figure}[ht]
\begin{lstlisting}
Compute(NOT, y) {
    /* ny is the number of points in y. */
    for (i = 0; i < ny; i++) {
        result[i].y = -y[i].y;
    }
    return result;
}
\end{lstlisting}
\label{fig:not}
\caption{The NOT operator.}
\end{figure}

\subsection{AND}

The $\And$ operator basically performs a point-wise minimum between both incoming signals.
This is complicated by the fact that signal values need to be interpolated for all
cases in which contains time points not found in the other signal. Additionally,
all intersections between both signals must also be added to the result.

\begin{figure}[ht]
\begin{lstlisting}
Compute(AND, x, y) {
    ts = /* union of all time points in x, y, and all intersections between them */;
    i = 0;
    for (t in ts) {
        result[i].t = t;
        result[i].y = min(
            interpolate(x at time t),
            interpolate(y at time t));
        i++;
    }
    return result;
}
\end{lstlisting}
\label{fig:and}
\caption{The AND operator.}
\end{figure}

\subsection{EVTL}

The sequential $\Evtl$ implementation is simply a reverse running maximum, again
complicated by the existence of intersections between the current running maximum
and the signal.

\begin{figure}[ht]
\begin{lstlisting}
Compute(EVTL, y) {
    mx = y[ny - 1].y;
    result.push_front({ y[ny - 1].t, mx });

    for (i = ny - 2; i >= 0; i--) {
        if (y[i + 1].y < mx && y[i].y > mx) {
            t = /* Interpolate time of intersection */
            result.push_front({ t, mx });
        }
        mx = max(y[i].y, mx);
        result.push_front({ y[i].t, mx });
    }
    return result
}
\end{lstlisting}
\label{fig:evtl}
\caption{The EVTL operator.}
\end{figure}


\subsection{UNTIL}

\subsection{BEVTL}

\section{Objectives}

\section{Design Overview}

\section{Implementation Plan}

\end{document}
